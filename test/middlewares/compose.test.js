const { createMockMiddleware, createMockPacket } = require('../create-mocks')
const { compose } = require('../../src/middlewares/compose')

describe('Composing middleware', () => {
  test('Composing nothing returns identity', () => {
    const packet = createMockPacket()
    const comp = compose()
    expect(comp.run(packet)).toEqual(packet)
    expect(comp.type).toEqual('identity')
  })

  test('Composing one middleware returns itself', () => {
    const packet = createMockPacket()
    const m1 = createMockMiddleware()
    m1.run.mockImplementation((packet) => ({ ...packet, ...{ webhook: { hello: 'world' }}}))
    const comp = compose(m1)
    const result = comp.run(packet)
    expect(m1.run).toHaveBeenCalled()
    expect(m1.type).toEqual('mock')
    expect(result).toEqual(m1.run(packet))
  })

  test('Composing multiple middleware runs middleware from left to right', () => {
    const packet = createMockPacket()
    const m1 = createMockMiddleware()
    const m2 = createMockMiddleware()
    const m3 = createMockMiddleware()
    m1.run.mockImplementation((packet) => ({ ...packet, ...{ webhook: { hello: 'world' }}}))
    m2.run.mockImplementation((packet) => ({ ...packet, ...{ webhook: { hello: packet.webhook.hello + 's' }}}))
    m3.run.mockImplementation((packet) => ({ ...packet, ...{ webhook: { hello: packet.webhook.hello.toUpperCase() }}}))
    const comp = compose(m1, m2, m3)
    const result = comp.run(packet)
    expect(m1.run).toHaveBeenCalled()
    expect(m2.run).toHaveBeenCalled()
    expect(m3.run).toHaveBeenCalled()
    expect(result).toEqual(m3.run(m2.run(m1.run(packet))))
    expect(comp.type).toEqual('composed')
    expect(comp).toHaveProperty('children')
    expect(comp.children).toEqual([m1, m2, m3])
  })

  test('Composed middleware can be recursively composed', () => {
    const packet = createMockPacket()
    const m1 = createMockMiddleware()
    const m2 = createMockMiddleware()
    const m3 = createMockMiddleware()
    m1.run.mockImplementation((packet) => ({ ...packet, ...{ webhook: { hello: 'world' }}}))
    m2.run.mockImplementation((packet) => ({ ...packet, ...{ webhook: { hello: packet.webhook.hello + 's' }}}))
    m3.run.mockImplementation((packet) => ({ ...packet, ...{ webhook: { hello: packet.webhook.hello.toUpperCase() }}}))
    const c1 = compose(m1, m2)
    const c2 = compose(c1, m3)
    const result = c2.run(packet)
    expect(m1.run).toHaveBeenCalled()
    expect(m2.run).toHaveBeenCalled()
    expect(m3.run).toHaveBeenCalled()
    expect(result).toEqual(m3.run(m2.run(m1.run(packet))))
    expect(c2.type).toEqual('composed')
    expect(c2).toHaveProperty('children')
    expect(c2.children).toEqual([c1, m3])
  })
})